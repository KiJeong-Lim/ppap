module Json.JsonLexer where
import Data.Ratio
import qualified Control.Monad.Trans.State.Strict as XState
import qualified Data.Functor.Identity as XIdentity
import qualified Data.Map.Strict as XMap
import qualified Data.Set as XSet

data JsonToken loc
    = T_lbrace loc
    | T_rbrace loc
    | T_lbracket loc
    | T_rbracket loc
    | T_comma loc
    | T_semicolon loc
    | T_true loc
    | T_false loc
    | T_null loc
    | T_string loc String
    | T_integer loc Integer
    | T_fraction loc Rational
    | T_exponent loc Double
    deriving (Eq, Show)
instance Functor (JsonToken) where
    fmap f (T_lbrace loc) = T_lbrace (f loc)
    fmap f (T_rbrace loc) = T_rbrace (f loc)
    fmap f (T_lbracket loc) = T_lbracket (f loc)
    fmap f (T_rbracket loc) = T_rbracket (f loc)
    fmap f (T_comma loc) = T_comma (f loc)
    fmap f (T_semicolon loc) = T_semicolon (f loc)
    fmap f (T_true loc) = T_true (f loc)
    fmap f (T_false loc) = T_false (f loc)
    fmap f (T_null loc) = T_null (f loc)
    fmap f (T_string loc str) = T_string (f loc) str
    fmap f (T_integer loc n) = T_integer (f loc) n
    fmap f (T_fraction loc q) = T_fraction (f loc) q
    fmap f (T_exponent loc x) = T_exponent (f loc) x
getLoc :: JsonToken a -> a
getLoc (T_lbrace loc) = loc
getLoc (T_rbrace loc) = loc
getLoc (T_lbracket loc) = loc
getLoc (T_rbracket loc) = loc
getLoc (T_comma loc) = loc
getLoc (T_semicolon loc) = loc
getLoc (T_true loc) = loc
getLoc (T_false loc) = loc
getLoc (T_null loc) = loc
getLoc (T_string loc str) = loc
getLoc (T_integer loc n) = loc
getLoc (T_fraction loc q) = loc
getLoc (T_exponent loc x) = loc

-- the following codes are generated by LGS.

data DFA
    = DFA
        { getInitialQOfDFA :: Int
        , getFinalQsOfDFA :: XMap.Map Int Int
        , getTransitionsOfDFA :: XMap.Map (Int, Char) Int
        , getMarkedQsOfDFA :: XMap.Map Int (Bool, XSet.Set Int)
        , getPseudoFinalsOfDFA :: XSet.Set Int
        }
    deriving ()

jsonlexer :: String -> Either (Int, Int) [JsonToken (Int, Int)]
jsonlexer = jsonlexer_this . addLoc 1 1 where
    --  0: "\"" ([. \ '\\' \ '\"'] + "\\" ['\"' '/' '\\' 'b' 'f' 'n' 'r' 't'] + "\\u" ['0'-'9' 'A'-'F' 'a'-'f'] ['0'-'9' 'A'-'F' 'a'-'f'] ['0'-'9' 'A'-'F' 'a'-'f'] ['0'-'9' 'A'-'F' 'a'-'f'])* "\\"
    --  1: "\"" ([. \ '\\' \ '\"'] + "\\" ['\"' '/' '\\' 'b' 'f' 'n' 'r' 't'] + "\\u" ['0'-'9' 'A'-'F' 'a'-'f'] ['0'-'9' 'A'-'F' 'a'-'f'] ['0'-'9' 'A'-'F' 'a'-'f'] ['0'-'9' 'A'-'F' 'a'-'f'])* "\\u" ['0'-'9' 'A'-'F' 'a'-'f'] ['0'-'9' 'A'-'F' 'a'-'f'] ['0'-'9' 'A'-'F' 'a'-'f']
    --  2: "\"" ([. \ '\\' \ '\"'] + "\\" ['\"' '/' '\\' 'b' 'f' 'n' 'r' 't'] + "\\u" ['0'-'9' 'A'-'F' 'a'-'f'] ['0'-'9' 'A'-'F' 'a'-'f'] ['0'-'9' 'A'-'F' 'a'-'f'] ['0'-'9' 'A'-'F' 'a'-'f'])* "\\u" ['0'-'9' 'A'-'F' 'a'-'f'] ['0'-'9' 'A'-'F' 'a'-'f']
    --  3: "\"" ([. \ '\\' \ '\"'] + "\\" ['\"' '/' '\\' 'b' 'f' 'n' 'r' 't'] + "\\u" ['0'-'9' 'A'-'F' 'a'-'f'] ['0'-'9' 'A'-'F' 'a'-'f'] ['0'-'9' 'A'-'F' 'a'-'f'] ['0'-'9' 'A'-'F' 'a'-'f'])* "\\u" ['0'-'9' 'A'-'F' 'a'-'f']
    --  4: "\"" ([. \ '\\' \ '\"'] + "\\" ['\"' '/' '\\' 'b' 'f' 'n' 'r' 't'] + "\\u" ['0'-'9' 'A'-'F' 'a'-'f'] ['0'-'9' 'A'-'F' 'a'-'f'] ['0'-'9' 'A'-'F' 'a'-'f'] ['0'-'9' 'A'-'F' 'a'-'f'])* "\\u"
    --  5: "tr"
    --  6: "fal"
    --  7: "fa"
    --  8: "f"
    --  9: "t"
    -- 10: "nu"
    -- 11: "n"
    -- 13: "\"" ([. \ '\\' \ '\"'] + "\\" ['\"' '/' '\\' 'b' 'f' 'n' 'r' 't'] + "\\u" ['0'-'9' 'A'-'F' 'a'-'f'] ['0'-'9' 'A'-'F' 'a'-'f'] ['0'-'9' 'A'-'F' 'a'-'f'] ['0'-'9' 'A'-'F' 'a'-'f'])*
    -- 14: "-"
    -- 15: (("0" + "-0") "." ['0'-'9'] + "-"? ['1'-'9'] ['0'-'9']* "." ['0'-'9']) ['0'-'9']* ['E' 'e']
    -- 16: ("0" + "-0") "." + "-"? ['1'-'9'] ['0'-'9']* "."
    -- 17: (("0" + "-0") "." ['0'-'9'] + "-"? ['1'-'9'] ['0'-'9']* "." ['0'-'9']) ['0'-'9']* ['E' 'e'] ['+' '-']
    -- 18: "tru"
    -- 19: "fals"
    -- 20: "nul"
    -- 21: ""
    -- 22: "{"
    -- 23: "}"
    -- 24: "["
    -- 25: "]"
    -- 26: ","
    -- 27: ":"
    -- 28: "true"
    -- 29: "false"
    -- 30: "null"
    -- 31: "\"" ([. \ '\\' \ '\"'] + "\\" ['\"' '/' '\\' 'b' 'f' 'n' 'r' 't'] + "\\u" ['0'-'9' 'A'-'F' 'a'-'f'] ['0'-'9' 'A'-'F' 'a'-'f'] ['0'-'9' 'A'-'F' 'a'-'f'] ['0'-'9' 'A'-'F' 'a'-'f'])* "\""
    -- 32: "0" + "-0"
    -- 33: "-"? ['1'-'9'] ['0'-'9']*
    -- 34: ("0" + "-0") "." ['0'-'9'] + "-"? ['1'-'9'] ['0'-'9']* "." ['0'-'9'] + (("0" + "-0") "." ['0'-'9'] + "-"? ['1'-'9'] ['0'-'9']* "." ['0'-'9']) ['0'-'9']*
    -- 35: (("0" + "-0") "." ['0'-'9'] + "-"? ['1'-'9'] ['0'-'9']* "." ['0'-'9']) ['0'-'9']* ['E' 'e'] ['+' '-']? ['0'-'9'] + (("0" + "-0") "." ['0'-'9'] + "-"? ['1'-'9'] ['0'-'9']* "." ['0'-'9']) ['0'-'9']* ['E' 'e'] ['+' '-']? ['0'-'9']+
    -- 36: ['\n' ' ']+
    theDFA :: DFA
    theDFA = DFA
        { getInitialQOfDFA = 21
        , getFinalQsOfDFA = XMap.fromAscList [(22, 1), (23, 2), (24, 3), (25, 4), (26, 5), (27, 6), (28, 7), (29, 8), (30, 9), (31, 10), (32, 11), (33, 11), (34, 12), (35, 13), (36, 14)]
        , getTransitionsOfDFA = XMap.fromAscList 
            [ ((0, '"'), 13), ((0, '/'), 13), ((0, '\\'), 13), ((0, 'b'), 13), ((0, 'f'), 13), ((0, 'n'), 13), ((0, 'r'), 13), ((0, 't'), 13), ((0, 'u'), 4)
            , ((1, '0'), 13), ((1, '1'), 13), ((1, '2'), 13), ((1, '3'), 13), ((1, '4'), 13), ((1, '5'), 13), ((1, '6'), 13), ((1, '7'), 13), ((1, '8'), 13), ((1, '9'), 13), ((1, 'A'), 13), ((1, 'B'), 13), ((1, 'C'), 13), ((1, 'D'), 13), ((1, 'E'), 13), ((1, 'F'), 13), ((1, 'a'), 13), ((1, 'b'), 13), ((1, 'c'), 13), ((1, 'd'), 13), ((1, 'e'), 13), ((1, 'f'), 13)
            , ((2, '0'), 1), ((2, '1'), 1), ((2, '2'), 1), ((2, '3'), 1), ((2, '4'), 1), ((2, '5'), 1), ((2, '6'), 1), ((2, '7'), 1), ((2, '8'), 1), ((2, '9'), 1), ((2, 'A'), 1), ((2, 'B'), 1), ((2, 'C'), 1), ((2, 'D'), 1), ((2, 'E'), 1), ((2, 'F'), 1), ((2, 'a'), 1), ((2, 'b'), 1), ((2, 'c'), 1), ((2, 'd'), 1), ((2, 'e'), 1), ((2, 'f'), 1)
            , ((3, '0'), 2), ((3, '1'), 2), ((3, '2'), 2), ((3, '3'), 2), ((3, '4'), 2), ((3, '5'), 2), ((3, '6'), 2), ((3, '7'), 2), ((3, '8'), 2), ((3, '9'), 2), ((3, 'A'), 2), ((3, 'B'), 2), ((3, 'C'), 2), ((3, 'D'), 2), ((3, 'E'), 2), ((3, 'F'), 2), ((3, 'a'), 2), ((3, 'b'), 2), ((3, 'c'), 2), ((3, 'd'), 2), ((3, 'e'), 2), ((3, 'f'), 2)
            , ((4, '0'), 3), ((4, '1'), 3), ((4, '2'), 3), ((4, '3'), 3), ((4, '4'), 3), ((4, '5'), 3), ((4, '6'), 3), ((4, '7'), 3), ((4, '8'), 3), ((4, '9'), 3), ((4, 'A'), 3), ((4, 'B'), 3), ((4, 'C'), 3), ((4, 'D'), 3), ((4, 'E'), 3), ((4, 'F'), 3), ((4, 'a'), 3), ((4, 'b'), 3), ((4, 'c'), 3), ((4, 'd'), 3), ((4, 'e'), 3), ((4, 'f'), 3)
            , ((5, 'u'), 18)
            , ((6, 's'), 19)
            , ((7, 'l'), 6)
            , ((8, 'a'), 7)
            , ((9, 'r'), 5)
            , ((10, 'l'), 20)
            , ((11, 'u'), 10)
            , ((13, '\n'), 13), ((13, ' '), 13), ((13, '!'), 13), ((13, '"'), 31), ((13, '#'), 13), ((13, '$'), 13), ((13, '%'), 13), ((13, '&'), 13), ((13, '\''), 13), ((13, '('), 13), ((13, ')'), 13), ((13, '*'), 13), ((13, '+'), 13), ((13, ','), 13), ((13, '-'), 13), ((13, '.'), 13), ((13, '/'), 13), ((13, '0'), 13), ((13, '1'), 13), ((13, '2'), 13), ((13, '3'), 13), ((13, '4'), 13), ((13, '5'), 13), ((13, '6'), 13), ((13, '7'), 13), ((13, '8'), 13), ((13, '9'), 13), ((13, ':'), 13), ((13, ';'), 13), ((13, '<'), 13), ((13, '='), 13), ((13, '>'), 13), ((13, '?'), 13), ((13, '@'), 13), ((13, 'A'), 13), ((13, 'B'), 13), ((13, 'C'), 13), ((13, 'D'), 13), ((13, 'E'), 13), ((13, 'F'), 13), ((13, 'G'), 13), ((13, 'H'), 13), ((13, 'I'), 13), ((13, 'J'), 13), ((13, 'K'), 13), ((13, 'L'), 13), ((13, 'M'), 13), ((13, 'N'), 13), ((13, 'O'), 13), ((13, 'P'), 13), ((13, 'Q'), 13), ((13, 'R'), 13), ((13, 'S'), 13), ((13, 'T'), 13), ((13, 'U'), 13), ((13, 'V'), 13), ((13, 'W'), 13), ((13, 'X'), 13), ((13, 'Y'), 13), ((13, 'Z'), 13), ((13, '['), 13), ((13, '\\'), 0), ((13, ']'), 13), ((13, '^'), 13), ((13, '_'), 13), ((13, '`'), 13), ((13, 'a'), 13), ((13, 'b'), 13), ((13, 'c'), 13), ((13, 'd'), 13), ((13, 'e'), 13), ((13, 'f'), 13), ((13, 'g'), 13), ((13, 'h'), 13), ((13, 'i'), 13), ((13, 'j'), 13), ((13, 'k'), 13), ((13, 'l'), 13), ((13, 'm'), 13), ((13, 'n'), 13), ((13, 'o'), 13), ((13, 'p'), 13), ((13, 'q'), 13), ((13, 'r'), 13), ((13, 's'), 13), ((13, 't'), 13), ((13, 'u'), 13), ((13, 'v'), 13), ((13, 'w'), 13), ((13, 'x'), 13), ((13, 'y'), 13), ((13, 'z'), 13), ((13, '{'), 13), ((13, '|'), 13), ((13, '}'), 13), ((13, '~'), 13)
            , ((14, '0'), 32), ((14, '1'), 33), ((14, '2'), 33), ((14, '3'), 33), ((14, '4'), 33), ((14, '5'), 33), ((14, '6'), 33), ((14, '7'), 33), ((14, '8'), 33), ((14, '9'), 33)
            , ((15, '+'), 17), ((15, '-'), 17), ((15, '0'), 35), ((15, '1'), 35), ((15, '2'), 35), ((15, '3'), 35), ((15, '4'), 35), ((15, '5'), 35), ((15, '6'), 35), ((15, '7'), 35), ((15, '8'), 35), ((15, '9'), 35)
            , ((16, '0'), 34), ((16, '1'), 34), ((16, '2'), 34), ((16, '3'), 34), ((16, '4'), 34), ((16, '5'), 34), ((16, '6'), 34), ((16, '7'), 34), ((16, '8'), 34), ((16, '9'), 34)
            , ((17, '0'), 35), ((17, '1'), 35), ((17, '2'), 35), ((17, '3'), 35), ((17, '4'), 35), ((17, '5'), 35), ((17, '6'), 35), ((17, '7'), 35), ((17, '8'), 35), ((17, '9'), 35)
            , ((18, 'e'), 28)
            , ((19, 'e'), 29)
            , ((20, 'l'), 30)
            , ((21, '\n'), 36), ((21, ' '), 36), ((21, '"'), 13), ((21, ','), 26), ((21, '-'), 14), ((21, '0'), 32), ((21, '1'), 33), ((21, '2'), 33), ((21, '3'), 33), ((21, '4'), 33), ((21, '5'), 33), ((21, '6'), 33), ((21, '7'), 33), ((21, '8'), 33), ((21, '9'), 33), ((21, ':'), 27), ((21, '['), 24), ((21, ']'), 25), ((21, 'f'), 8), ((21, 'n'), 11), ((21, 't'), 9), ((21, '{'), 22), ((21, '}'), 23)
            , ((32, '.'), 16)
            , ((33, '.'), 16), ((33, '0'), 33), ((33, '1'), 33), ((33, '2'), 33), ((33, '3'), 33), ((33, '4'), 33), ((33, '5'), 33), ((33, '6'), 33), ((33, '7'), 33), ((33, '8'), 33), ((33, '9'), 33)
            , ((34, '0'), 34), ((34, '1'), 34), ((34, '2'), 34), ((34, '3'), 34), ((34, '4'), 34), ((34, '5'), 34), ((34, '6'), 34), ((34, '7'), 34), ((34, '8'), 34), ((34, '9'), 34), ((34, 'E'), 15), ((34, 'e'), 15)
            , ((35, '0'), 35), ((35, '1'), 35), ((35, '2'), 35), ((35, '3'), 35), ((35, '4'), 35), ((35, '5'), 35), ((35, '6'), 35), ((35, '7'), 35), ((35, '8'), 35), ((35, '9'), 35)
            , ((36, '\n'), 36), ((36, ' '), 36)
            ]
        , getMarkedQsOfDFA = XMap.fromAscList []
        , getPseudoFinalsOfDFA = XSet.fromAscList []
        }
    runDFA :: DFA -> [((Int, Int), Char)] -> Either (Int, Int) ((Maybe Int, [((Int, Int), Char)]), [((Int, Int), Char)])
    runDFA (DFA q0 qfs deltas markeds pseudo_finals) = if XSet.null pseudo_finals then Right . XIdentity.runIdentity . runFast else runSlow where
        loop1 :: Int -> [((Int, Int), Char)] -> [((Int, Int), Char)] -> XState.StateT (Maybe Int, [((Int, Int), Char)]) XIdentity.Identity [((Int, Int), Char)]
        loop1 q buffer [] = return buffer
        loop1 q buffer (ch : str) = do
            (latest, accepted) <- XState.get
            case XMap.lookup (q, snd ch) deltas of
                Nothing -> return (buffer ++ [ch] ++ str)
                Just p -> case XMap.lookup p qfs of
                    Nothing -> loop1 p (buffer ++ [ch]) str
                    latest' -> do
                        XState.put (latest', accepted ++ buffer ++ [ch])
                        loop1 p [] str
        loop2 :: XSet.Set Int -> Int -> [((Int, Int), Char)] -> [((Int, Int), Char)] -> XState.StateT [((Int, Int), Char)] XIdentity.Identity [((Int, Int), Char)]
        loop2 qs q [] buffer = return buffer
        loop2 qs q (ch : str) buffer = do
            case XMap.lookup (q, snd ch) deltas of
                Nothing -> return (buffer ++ [ch] ++ str)
                Just p -> case p `XSet.member` qs of
                    False -> loop2 qs p str (buffer ++ [ch])
                    True -> do
                        accepted <- XState.get
                        XState.put (accepted ++ buffer ++ [ch])
                        loop2 qs p str []
        loop3 :: XSet.Set Int -> Int -> [((Int, Int), Char)] -> [((Int, Int), Char)] -> XState.StateT [((Int, Int), Char)] XIdentity.Identity [((Int, Int), Char)]
        loop3 qs q [] buffer = return buffer
        loop3 qs q (ch : str) buffer = do
            case XMap.lookup (q, snd ch) deltas of
                Nothing -> return (buffer ++ [ch] ++ str)
                Just p -> case p `XSet.member` qs of
                    False -> loop3 qs p str (buffer ++ [ch])
                    True -> do
                        accepted <- XState.get
                        XState.put (accepted ++ buffer ++ [ch])
                        return str
        runFast :: [((Int, Int), Char)] -> XIdentity.Identity ((Maybe Int, [((Int, Int), Char)]), [((Int, Int), Char)])
        runFast input = do
            (rest, (latest, accepted)) <- XState.runStateT (loop1 q0 [] input) (Nothing, [])
            case latest >>= flip XMap.lookup markeds of
                Nothing -> return ((latest, accepted), rest)
                Just (True, qs) -> do
                    (rest', accepted') <- XState.runStateT (loop2 qs q0 accepted []) []
                    return ((latest, accepted'), rest' ++ rest)
                Just (False, qs) -> do
                    (rest', accepted') <- XState.runStateT (loop3 qs q0 accepted []) []
                    return ((latest, accepted'), rest' ++ rest)
        runSlow :: [((Int, Int), Char)] -> Either (Int, Int) ((Maybe Int, [((Int, Int), Char)]), [((Int, Int), Char)])
        runSlow = undefined
    addLoc :: Int -> Int -> String -> [((Int, Int), Char)]
    addLoc _ _ [] = []
    addLoc row col (ch : chs) = if ch == '\n' then ((row, col), ch) : addLoc (row + 1) 1 chs else ((row, col), ch) : addLoc row (col + 1) chs
    jsonlexer_this :: [((Int, Int), Char)] -> Either (Int, Int) [JsonToken (Int, Int)]
    jsonlexer_this [] = return []
    jsonlexer_this str0 = do
        let return_one my_token = return [my_token]
        dfa_output <- runDFA theDFA str0
        (str1, piece) <- case dfa_output of
            ((_, []), _) -> Left (fst (head str0))
            ((Just label, accepted), rest) -> return (rest, ((label, map snd accepted), (fst (head accepted), fst (head (reverse accepted)))))
            _ -> Left (fst (head str0))
        tokens1 <- case piece of
            ((1, this), ((row1, col1), (row2, col2))) -> return_one (T_lbrace (row1, col1))
            ((2, this), ((row1, col1), (row2, col2))) -> return_one (T_rbrace (row1, col1))
            ((3, this), ((row1, col1), (row2, col2))) -> return_one (T_lbracket (row1, col1))
            ((4, this), ((row1, col1), (row2, col2))) -> return_one (T_rbracket (row1, col1))
            ((5, this), ((row1, col1), (row2, col2))) -> return_one (T_comma (row1, col1))
            ((6, this), ((row1, col1), (row2, col2))) -> return_one (T_semicolon (row1, col1))
            ((7, this), ((row1, col1), (row2, col2))) -> return_one (T_true (row1, col1))
            ((8, this), ((row1, col1), (row2, col2))) -> return_one (T_false (row1, col1))
            ((9, this), ((row1, col1), (row2, col2))) -> return_one (T_null (row1, col1))
            ((10, this), ((row1, col1), (row2, col2))) -> return_one (T_string (row1, col1) (read this))
            ((11, this), ((row1, col1), (row2, col2))) -> return_one (T_integer (row1, col1) (read this))
            ((12, this), ((row1, col1), (row2, col2))) -> return_one (T_fraction (row1, col1) (read this))
            ((13, this), ((row1, col1), (row2, col2))) -> return_one (T_exponent (row1, col1) (read this))
            ((14, this), ((row1, col1), (row2, col2))) -> return []
        tokens2 <- jsonlexer_this str1
        return (tokens1 ++ tokens2)
