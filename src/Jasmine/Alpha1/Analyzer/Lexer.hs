module Jasmine.Alpha1.Analyzer.Lexer where

import qualified Control.Monad.Trans.State.Strict as XState
import qualified Data.Functor.Identity as XIdentity
import qualified Data.Map.Strict as XMap
import qualified Data.Set as XSet


data Token
    = StrLit String
    deriving (Show)


-- the following codes are generated by LGS.

data DFA
    = DFA
        { getInitialQOfDFA :: Int
        , getFinalQsOfDFA :: XMap.Map Int Int
        , getTransitionsOfDFA :: XMap.Map (Int, Char) Int
        , getMarkedQsOfDFA :: XMap.Map Int (Bool, XSet.Set Int)
        }
    deriving ()

runJasmineLexer :: String -> Either (Int, Int) [Token]
runJasmineLexer = doLexing . addLoc 1 1 where
    -- 1: "_"
    -- 2: ""
    -- 3: ['a'-'z'] ['0'-'9' 'A'-'Z' 'a'-'z']* "_" ['0'-'9' 'A'-'Z' '_' 'a'-'z']* "{"
    -- 4: ['a'-'z'] ['0'-'9' 'A'-'Z' 'a'-'z']* ("_" ['0'-'9' 'A'-'Z' '_' 'a'-'z']* ['0'-'9' 'A'-'Z' 'a'-'z']+)?
    -- 5: ['a'-'z'] ['0'-'9' 'A'-'Z' 'a'-'z']* "_" ['0'-'9' 'A'-'Z' '_' 'a'-'z']*
    -- 6: "_{"
    -- 7: "}"
    -- 8: ['\n' ' ']+
    theDFA :: DFA
    theDFA = DFA
        { getInitialQOfDFA = 2
        , getFinalQsOfDFA = XMap.fromAscList [(3, 1), (4, 1), (5, 1), (6, 2), (7, 3), (8, 4)]
        , getTransitionsOfDFA = XMap.fromAscList 
            [ ((1, '{'), 6)
            , ((2, '\n'), 8), ((2, ' '), 8), ((2, '_'), 1), ((2, 'a'), 4), ((2, 'b'), 4), ((2, 'c'), 4), ((2, 'd'), 4), ((2, 'e'), 4), ((2, 'f'), 4), ((2, 'g'), 4), ((2, 'h'), 4), ((2, 'i'), 4), ((2, 'j'), 4), ((2, 'k'), 4), ((2, 'l'), 4), ((2, 'm'), 4), ((2, 'n'), 4), ((2, 'o'), 4), ((2, 'p'), 4), ((2, 'q'), 4), ((2, 'r'), 4), ((2, 's'), 4), ((2, 't'), 4), ((2, 'u'), 4), ((2, 'v'), 4), ((2, 'w'), 4), ((2, 'x'), 4), ((2, 'y'), 4), ((2, 'z'), 4), ((2, '}'), 7)
            , ((4, '0'), 4), ((4, '1'), 4), ((4, '2'), 4), ((4, '3'), 4), ((4, '4'), 4), ((4, '5'), 4), ((4, '6'), 4), ((4, '7'), 4), ((4, '8'), 4), ((4, '9'), 4), ((4, 'A'), 4), ((4, 'B'), 4), ((4, 'C'), 4), ((4, 'D'), 4), ((4, 'E'), 4), ((4, 'F'), 4), ((4, 'G'), 4), ((4, 'H'), 4), ((4, 'I'), 4), ((4, 'J'), 4), ((4, 'K'), 4), ((4, 'L'), 4), ((4, 'M'), 4), ((4, 'N'), 4), ((4, 'O'), 4), ((4, 'P'), 4), ((4, 'Q'), 4), ((4, 'R'), 4), ((4, 'S'), 4), ((4, 'T'), 4), ((4, 'U'), 4), ((4, 'V'), 4), ((4, 'W'), 4), ((4, 'X'), 4), ((4, 'Y'), 4), ((4, 'Z'), 4), ((4, '_'), 5), ((4, 'a'), 4), ((4, 'b'), 4), ((4, 'c'), 4), ((4, 'd'), 4), ((4, 'e'), 4), ((4, 'f'), 4), ((4, 'g'), 4), ((4, 'h'), 4), ((4, 'i'), 4), ((4, 'j'), 4), ((4, 'k'), 4), ((4, 'l'), 4), ((4, 'm'), 4), ((4, 'n'), 4), ((4, 'o'), 4), ((4, 'p'), 4), ((4, 'q'), 4), ((4, 'r'), 4), ((4, 's'), 4), ((4, 't'), 4), ((4, 'u'), 4), ((4, 'v'), 4), ((4, 'w'), 4), ((4, 'x'), 4), ((4, 'y'), 4), ((4, 'z'), 4)
            , ((5, '0'), 4), ((5, '1'), 4), ((5, '2'), 4), ((5, '3'), 4), ((5, '4'), 4), ((5, '5'), 4), ((5, '6'), 4), ((5, '7'), 4), ((5, '8'), 4), ((5, '9'), 4), ((5, 'A'), 4), ((5, 'B'), 4), ((5, 'C'), 4), ((5, 'D'), 4), ((5, 'E'), 4), ((5, 'F'), 4), ((5, 'G'), 4), ((5, 'H'), 4), ((5, 'I'), 4), ((5, 'J'), 4), ((5, 'K'), 4), ((5, 'L'), 4), ((5, 'M'), 4), ((5, 'N'), 4), ((5, 'O'), 4), ((5, 'P'), 4), ((5, 'Q'), 4), ((5, 'R'), 4), ((5, 'S'), 4), ((5, 'T'), 4), ((5, 'U'), 4), ((5, 'V'), 4), ((5, 'W'), 4), ((5, 'X'), 4), ((5, 'Y'), 4), ((5, 'Z'), 4), ((5, '_'), 5), ((5, 'a'), 4), ((5, 'b'), 4), ((5, 'c'), 4), ((5, 'd'), 4), ((5, 'e'), 4), ((5, 'f'), 4), ((5, 'g'), 4), ((5, 'h'), 4), ((5, 'i'), 4), ((5, 'j'), 4), ((5, 'k'), 4), ((5, 'l'), 4), ((5, 'm'), 4), ((5, 'n'), 4), ((5, 'o'), 4), ((5, 'p'), 4), ((5, 'q'), 4), ((5, 'r'), 4), ((5, 's'), 4), ((5, 't'), 4), ((5, 'u'), 4), ((5, 'v'), 4), ((5, 'w'), 4), ((5, 'x'), 4), ((5, 'y'), 4), ((5, 'z'), 4), ((5, '{'), 3)
            , ((8, '\n'), 8), ((8, ' '), 8)
            ]
        , getMarkedQsOfDFA = XMap.fromAscList 
            [ (1, (False, XSet.fromAscList [4, 5]))
            ]
        }
    runDFA :: DFA -> [((Int, Int), Char)] -> ((Maybe Int, [((Int, Int), Char)]), [((Int, Int), Char)])
    runDFA (DFA q0 qfs deltas markeds) = XIdentity.runIdentity . go where
        loop1 :: Int -> [((Int, Int), Char)] -> [((Int, Int), Char)] -> XState.StateT (Maybe Int, [((Int, Int), Char)]) XIdentity.Identity [((Int, Int), Char)]
        loop1 q buffer [] = return buffer
        loop1 q buffer (ch : str) = do
            (latest, accepted) <- XState.get
            case XMap.lookup (q, snd ch) deltas of
                Nothing -> return (buffer ++ [ch] ++ str)
                Just p -> case XMap.lookup p qfs of
                    Nothing -> loop1 p (buffer ++ [ch]) str
                    latest' -> do
                        XState.put (latest', accepted ++ buffer ++ [ch])
                        loop1 p [] str
        loop2 :: XSet.Set Int -> Int -> [((Int, Int), Char)] -> [((Int, Int), Char)] -> XState.StateT [((Int, Int), Char)] XIdentity.Identity [((Int, Int), Char)]
        loop2 qs q [] buffer = return buffer
        loop2 qs q (ch : str) buffer = do
            case XMap.lookup (q, snd ch) deltas of
                Nothing -> return (buffer ++ [ch] ++ str)
                Just p -> case p `XSet.member` qs of
                    False -> loop2 qs p str (buffer ++ [ch])
                    True -> do
                        accepted <- XState.get
                        XState.put (accepted ++ buffer ++ [ch])
                        loop2 qs p str []
        loop3 :: XSet.Set Int -> Int -> [((Int, Int), Char)] -> [((Int, Int), Char)] -> XState.StateT [((Int, Int), Char)] XIdentity.Identity [((Int, Int), Char)]
        loop3 qs q [] buffer = return buffer
        loop3 qs q (ch : str) buffer = do
            case XMap.lookup (q, snd ch) deltas of
                Nothing -> return (buffer ++ [ch] ++ str)
                Just p -> case p `XSet.member` qs of
                    False -> loop3 qs p str (buffer ++ [ch])
                    True -> do
                        accepted <- XState.get
                        XState.put (accepted ++ buffer ++ [ch])
                        return str
        go :: [((Int, Int), Char)] -> XIdentity.Identity ((Maybe Int, [((Int, Int), Char)]), [((Int, Int), Char)])
        go input = do
            (rest, (latest, accepted)) <- XState.runStateT (loop1 q0 [] input) (Nothing, [])
            case latest >>= flip XMap.lookup markeds of
                Nothing -> return ((latest, accepted), rest)
                Just (True, qs) -> do
                    (rest', accepted') <- XState.runStateT (loop2 qs q0 accepted []) []
                    return ((latest, accepted'), rest' ++ rest)
                Just (False, qs) -> do
                    (rest', accepted') <- XState.runStateT (loop3 qs q0 accepted []) []
                    return ((latest, accepted'), rest' ++ rest)
    addLoc :: Int -> Int -> String -> [((Int, Int), Char)]
    addLoc _ _ [] = []
    addLoc row col (ch : chs) = if ch == '\n' then ((row, col), ch) : addLoc (row + 1) 1 chs else ((row, col), ch) : addLoc row (col + 1) chs
    doLexing :: [((Int, Int), Char)] -> Either (Int, Int) [Token]
    doLexing [] = return []
    doLexing str0 = do
        let returnJust = return . Just
        (str1, piece) <- case runDFA theDFA str0 of
            ((_, []), _) -> Left (fst (head str0))
            ((Just label, accepted), rest) -> return (rest, ((label, map snd accepted), (fst (head accepted), fst (head (reverse accepted)))))
            _ -> Left (fst (head str0))
        maybe_token <- case piece of
            ((1, this), ((row1, col1), (row2, col2))) -> returnJust (StrLit this)
            ((2, this), ((row1, col1), (row2, col2))) -> returnJust (StrLit this)
            ((3, this), ((row1, col1), (row2, col2))) -> returnJust (StrLit this)
            ((4, this), ((row1, col1), (row2, col2))) -> return Nothing
        fmap (maybe id (:) maybe_token) (doLexing str1)
