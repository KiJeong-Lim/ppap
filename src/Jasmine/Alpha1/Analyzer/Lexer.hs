module Jasmine.Alpha1.Analyzer.Lexer where

import qualified Control.Monad.Trans.State.Strict as XState
import qualified Data.Functor.Identity as XIdentity
import qualified Data.Map.Strict as XMap
import qualified Data.Set as XSet


data Token
    = StrLit String
    deriving (Show)


-- the following codes are generated by LGS.

data DFA
    = DFA
        { getInitialQOfDFA :: Int
        , getFinalQsOfDFA :: XMap.Map Int Int
        , getTransitionsOfDFA :: XMap.Map (Int, Char) Int
        , getMarkedQsOfDFA :: XMap.Map Int (Bool, XSet.Set Int)
        }
    deriving ()

runJasmineLexer :: String -> Either (Int, Int) [Token]
runJasmineLexer = doLexing . addLoc 1 1 where
    -- 1: "_"
    -- 2: ""
    -- 4: ['a'-'z'] ['0'-'9' 'A'-'Z' 'a'-'z']* "_" ['0'-'9' 'A'-'Z' '_' 'a'-'z']* "{"
    -- 5: ['a'-'z'] ['0'-'9' 'A'-'Z' 'a'-'z']* ("_" ['0'-'9' 'A'-'Z' '_' 'a'-'z']* ['0'-'9' 'A'-'Z' 'a'-'z']+)?
    -- 6: ['a'-'z'] ['0'-'9' 'A'-'Z' 'a'-'z']* "_" ['0'-'9' 'A'-'Z' '_' 'a'-'z']*
    -- 7: "_{"
    -- 8: "}"
    -- 9: ['\n' ' ']+
    theDFA :: DFA
    theDFA = DFA
        { getInitialQOfDFA = 2
        , getFinalQsOfDFA = XMap.fromAscList [(4, 1), (5, 1), (6, 1), (7, 2), (8, 3), (9, 4)]
        , getTransitionsOfDFA = XMap.fromAscList 
            [ ((1, '{'), 7)
            , ((2, '\n'), 9), ((2, ' '), 9), ((2, '_'), 1), ((2, 'a'), 5), ((2, 'b'), 5), ((2, 'c'), 5), ((2, 'd'), 5), ((2, 'e'), 5), ((2, 'f'), 5), ((2, 'g'), 5), ((2, 'h'), 5), ((2, 'i'), 5), ((2, 'j'), 5), ((2, 'k'), 5), ((2, 'l'), 5), ((2, 'm'), 5), ((2, 'n'), 5), ((2, 'o'), 5), ((2, 'p'), 5), ((2, 'q'), 5), ((2, 'r'), 5), ((2, 's'), 5), ((2, 't'), 5), ((2, 'u'), 5), ((2, 'v'), 5), ((2, 'w'), 5), ((2, 'x'), 5), ((2, 'y'), 5), ((2, 'z'), 5), ((2, '}'), 8)
            , ((5, '0'), 5), ((5, '1'), 5), ((5, '2'), 5), ((5, '3'), 5), ((5, '4'), 5), ((5, '5'), 5), ((5, '6'), 5), ((5, '7'), 5), ((5, '8'), 5), ((5, '9'), 5), ((5, 'A'), 5), ((5, 'B'), 5), ((5, 'C'), 5), ((5, 'D'), 5), ((5, 'E'), 5), ((5, 'F'), 5), ((5, 'G'), 5), ((5, 'H'), 5), ((5, 'I'), 5), ((5, 'J'), 5), ((5, 'K'), 5), ((5, 'L'), 5), ((5, 'M'), 5), ((5, 'N'), 5), ((5, 'O'), 5), ((5, 'P'), 5), ((5, 'Q'), 5), ((5, 'R'), 5), ((5, 'S'), 5), ((5, 'T'), 5), ((5, 'U'), 5), ((5, 'V'), 5), ((5, 'W'), 5), ((5, 'X'), 5), ((5, 'Y'), 5), ((5, 'Z'), 5), ((5, '_'), 6), ((5, 'a'), 5), ((5, 'b'), 5), ((5, 'c'), 5), ((5, 'd'), 5), ((5, 'e'), 5), ((5, 'f'), 5), ((5, 'g'), 5), ((5, 'h'), 5), ((5, 'i'), 5), ((5, 'j'), 5), ((5, 'k'), 5), ((5, 'l'), 5), ((5, 'm'), 5), ((5, 'n'), 5), ((5, 'o'), 5), ((5, 'p'), 5), ((5, 'q'), 5), ((5, 'r'), 5), ((5, 's'), 5), ((5, 't'), 5), ((5, 'u'), 5), ((5, 'v'), 5), ((5, 'w'), 5), ((5, 'x'), 5), ((5, 'y'), 5), ((5, 'z'), 5)
            , ((6, '0'), 5), ((6, '1'), 5), ((6, '2'), 5), ((6, '3'), 5), ((6, '4'), 5), ((6, '5'), 5), ((6, '6'), 5), ((6, '7'), 5), ((6, '8'), 5), ((6, '9'), 5), ((6, 'A'), 5), ((6, 'B'), 5), ((6, 'C'), 5), ((6, 'D'), 5), ((6, 'E'), 5), ((6, 'F'), 5), ((6, 'G'), 5), ((6, 'H'), 5), ((6, 'I'), 5), ((6, 'J'), 5), ((6, 'K'), 5), ((6, 'L'), 5), ((6, 'M'), 5), ((6, 'N'), 5), ((6, 'O'), 5), ((6, 'P'), 5), ((6, 'Q'), 5), ((6, 'R'), 5), ((6, 'S'), 5), ((6, 'T'), 5), ((6, 'U'), 5), ((6, 'V'), 5), ((6, 'W'), 5), ((6, 'X'), 5), ((6, 'Y'), 5), ((6, 'Z'), 5), ((6, '_'), 6), ((6, 'a'), 5), ((6, 'b'), 5), ((6, 'c'), 5), ((6, 'd'), 5), ((6, 'e'), 5), ((6, 'f'), 5), ((6, 'g'), 5), ((6, 'h'), 5), ((6, 'i'), 5), ((6, 'j'), 5), ((6, 'k'), 5), ((6, 'l'), 5), ((6, 'm'), 5), ((6, 'n'), 5), ((6, 'o'), 5), ((6, 'p'), 5), ((6, 'q'), 5), ((6, 'r'), 5), ((6, 's'), 5), ((6, 't'), 5), ((6, 'u'), 5), ((6, 'v'), 5), ((6, 'w'), 5), ((6, 'x'), 5), ((6, 'y'), 5), ((6, 'z'), 5), ((6, '{'), 4)
            , ((9, '\n'), 9), ((9, ' '), 9)
            ]
        , getMarkedQsOfDFA = XMap.fromAscList 
            [ (1, (False, XSet.fromAscList [5, 6]))
            ]
        }
    runDFA :: DFA -> [((Int, Int), Char)] -> ((Maybe Int, [((Int, Int), Char)]), [((Int, Int), Char)])
    runDFA (DFA q0 qfs deltas markeds) = XIdentity.runIdentity . go where
        loop1 :: Int -> [((Int, Int), Char)] -> [((Int, Int), Char)] -> XState.StateT (Maybe Int, [((Int, Int), Char)]) XIdentity.Identity [((Int, Int), Char)]
        loop1 q buffer [] = return buffer
        loop1 q buffer (ch : str) = do
            (latest, accepted) <- XState.get
            case XMap.lookup (q, snd ch) deltas of
                Nothing -> return (buffer ++ [ch] ++ str)
                Just p -> case XMap.lookup p qfs of
                    Nothing -> loop1 p (buffer ++ [ch]) str
                    latest' -> do
                        XState.put (latest', accepted ++ buffer ++ [ch])
                        loop1 p [] str
        loop2 :: XSet.Set Int -> Int -> [((Int, Int), Char)] -> [((Int, Int), Char)] -> XState.StateT [((Int, Int), Char)] XIdentity.Identity [((Int, Int), Char)]
        loop2 qs q [] buffer = return buffer
        loop2 qs q (ch : str) buffer = do
            case XMap.lookup (q, snd ch) deltas of
                Nothing -> return (buffer ++ [ch] ++ str)
                Just p -> case p `XSet.member` qs of
                    False -> loop2 qs p str (buffer ++ [ch])
                    True -> do
                        accepted <- XState.get
                        XState.put (accepted ++ buffer ++ [ch])
                        loop2 qs p str []
        loop3 :: XSet.Set Int -> Int -> [((Int, Int), Char)] -> [((Int, Int), Char)] -> XState.StateT [((Int, Int), Char)] XIdentity.Identity [((Int, Int), Char)]
        loop3 qs q [] buffer = return buffer
        loop3 qs q (ch : str) buffer = do
            case XMap.lookup (q, snd ch) deltas of
                Nothing -> return (buffer ++ [ch] ++ str)
                Just p -> case p `XSet.member` qs of
                    False -> loop3 qs p str (buffer ++ [ch])
                    True -> do
                        accepted <- XState.get
                        XState.put (accepted ++ buffer ++ [ch])
                        return str
        go :: [((Int, Int), Char)] -> XIdentity.Identity ((Maybe Int, [((Int, Int), Char)]), [((Int, Int), Char)])
        go input = do
            (rest, (latest, accepted)) <- XState.runStateT (loop1 q0 [] input) (Nothing, [])
            case latest >>= flip XMap.lookup markeds of
                Nothing -> return ((latest, accepted), rest)
                Just (True, qs) -> do
                    (rest', accepted') <- XState.runStateT (loop2 qs q0 accepted []) []
                    return ((latest, accepted'), rest' ++ rest)
                Just (False, qs) -> do
                    (rest', accepted') <- XState.runStateT (loop3 qs q0 accepted []) []
                    return ((latest, accepted'), rest' ++ rest)
    addLoc :: Int -> Int -> String -> [((Int, Int), Char)]
    addLoc _ _ [] = []
    addLoc row col (ch : chs) = if ch == '\n' then ((row, col), ch) : addLoc (row + 1) 1 chs else ((row, col), ch) : addLoc row (col + 1) chs
    doLexing :: [((Int, Int), Char)] -> Either (Int, Int) [Token]
    doLexing [] = return []
    doLexing str0 = do
        let returnJust = return . Just
        (str1, piece) <- case runDFA theDFA str0 of
            ((_, []), _) -> Left (fst (head str0))
            ((Just label, accepted), rest) -> return (rest, ((label, map snd accepted), (fst (head accepted), fst (head (reverse accepted)))))
            _ -> Left (fst (head str0))
        maybe_token <- case piece of
            ((1, this), ((row1, col1), (row2, col2))) -> returnJust (StrLit this)
            ((2, this), ((row1, col1), (row2, col2))) -> returnJust (StrLit this)
            ((3, this), ((row1, col1), (row2, col2))) -> returnJust (StrLit this)
            ((4, this), ((row1, col1), (row2, col2))) -> return Nothing
        fmap (maybe id (:) maybe_token) (doLexing str1)
