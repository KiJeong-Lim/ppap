module BlockArgument where
import qualified Control.Monad.Trans.Class as Y
import qualified Control.Monad.Trans.Except as Y
import qualified Control.Monad.Trans.State.Strict as Y
import qualified Data.Map.Strict as YMap
import qualified Data.Set as YSet

data Tok
    = LargeId String
    | SmallId String
    | LParen
    | RParen
    | Lambda
    deriving (Eq, Ord, Show)

data Term
    = Lam String Term
    | App Term Term
    | Var String
    deriving (Eq, Ord, Show)

main :: IO ()
main = do
    let example = [SmallId "sigma", LargeId "X", Lambda, LargeId "X", InfixSym "=", LargeId "X"]
    print (parser example)

-- the following codes are generated by PGS.

type ParserS = Int

type NSym = Int

type TSym = Int

data Sym
    = NS NSym
    | TS TSym
    deriving (Eq, Ord)

data Action
    = Shift ParserS
    | Reduce (NSym, [Sym])
    | Accept
    deriving (Eq)

data LR1Parser
    = LR1Parser
        { getInitialS :: ParserS
        , getActionTable :: YMap.Map (ParserS, TSym) Action
        , getReduceTable :: YMap.Map (ParserS, NSym) ParserS
        }
    deriving ()

data ParsingTree
    = PTLeaf (Tok)
    | PTBranch NSym [ParsingTree]
    deriving ()

hello :: [Tok] -> Either (Maybe (Tok)) (Term)
hello = fmap (getTerm0) . runLALR1 theLALR1Parser where
    getTerm0 :: ParsingTree -> (Term)
    getTerm0 (PTBranch _ [PTLeaf (LargeId nm_1), PTLeaf (Lambda), _3@(PTBranch guard3 _)])
        | [guard3] `elem` [[1]] = Lam (nm_1) (getTerm0 _3)
    getTerm0 (PTBranch _ [PTLeaf (SmallId nm_1), PTLeaf (Lambda), _3@(PTBranch guard3 _)])
        | [guard3] `elem` [[1]] = Lam (nm_1) (getTerm0 _3)
    getTerm0 (PTBranch _ [_1@(PTBranch guard1 _)])
        | [guard1] `elem` [[2]] = (getTerm1 _1)
    getTerm1 :: ParsingTree -> (Term)
    getTerm1 (PTBranch _ [_1@(PTBranch guard1 _), PTLeaf (InfixSym nm_2), _3@(PTBranch guard3 _)])
        | [guard1, guard3] `elem` [[3, 3]] = App (App (Var (nm_2)) (getTerm2 _1)) (getTerm2 _3)
    getTerm1 (PTBranch _ [_1@(PTBranch guard1 _)])
        | [guard1] `elem` [[3]] = (getTerm2 _1)
    getTerm2 :: ParsingTree -> (Term)
    getTerm2 (PTBranch _ [_1@(PTBranch guard1 _), PTLeaf (LargeId nm_2), PTLeaf (Lambda), _4@(PTBranch guard4 _)])
        | [guard1, guard4] `elem` [[4, 1]] = App (getTerm3 _1) (Lam (nm_2) (getTerm0 _4))
    getTerm2 (PTBranch _ [_1@(PTBranch guard1 _), PTLeaf (SmallId nm_2), PTLeaf (Lambda), _4@(PTBranch guard4 _)])
        | [guard1, guard4] `elem` [[4, 1]] = App (getTerm3 _1) (Lam (nm_2) (getTerm0 _4))
    getTerm2 (PTBranch _ [_1@(PTBranch guard1 _)])
        | [guard1] `elem` [[4]] = (getTerm3 _1)
    getTerm3 :: ParsingTree -> (Term)
    getTerm3 (PTBranch _ [_1@(PTBranch guard1 _), _2@(PTBranch guard2 _)])
        | [guard1, guard2] `elem` [[4, 5]] = App (getTerm3 _1) (getTerm4 _2)
    getTerm3 (PTBranch _ [_1@(PTBranch guard1 _)])
        | [guard1] `elem` [[5]] = (getTerm4 _1)
    getTerm4 :: ParsingTree -> (Term)
    getTerm4 (PTBranch _ [PTLeaf (LargeId nm_1)])
        | otherwise = Var (nm_1)
    getTerm4 (PTBranch _ [PTLeaf (SmallId nm_1)])
        | otherwise = Var (nm_1)
    getTerm4 (PTBranch _ [PTLeaf (LParen), _2@(PTBranch guard2 _), PTLeaf (RParen)])
        | [guard2] `elem` [[1]] = (getTerm0 _2)
    toTerminal :: (Tok) -> TSym
    toTerminal (LargeId nm) = 1
    toTerminal (SmallId nm) = 2
    toTerminal (LParen) = 3
    toTerminal (RParen) = 4
    toTerminal (Lambda) = 5
    toTerminal (InfixSym nm) = 6
    runLALR1 :: LR1Parser -> [Tok] -> Either (Maybe (Tok)) ParsingTree
    runLALR1 (LR1Parser getInitS getActionT getReduceT) = go where
        loop inputs = do
            let cur = if null inputs then 0 else toTerminal (head inputs)
                exception = Y.lift (if null inputs then Left Nothing else Left (Just (head inputs)))
            (stack, trees) <- Y.get
            case YMap.lookup (head stack, cur) getActionT of
                Nothing -> exception
                Just Accept -> return ()
                Just (Shift top') -> do
                    Y.put (top' : stack, PTLeaf (head inputs) : trees)
                    loop (tail inputs)
                Just (Reduce (lhs, rhs)) -> do
                    let n = length rhs
                    case YMap.lookup (stack !! n, lhs) getReduceT of
                        Nothing -> exception
                        Just top' -> do
                            Y.put (top' : drop n stack, PTBranch lhs (reverse (take n trees)) : drop n trees)
                            loop inputs
        go tokens = do
            (_, (_, result)) <- Y.runStateT (loop tokens) ([getInitS], [])
            case result of
                [output] -> return output
    theLALR1Parser :: LR1Parser
    theLALR1Parser = LR1Parser
        { getInitialS = 0
        , getActionTable = YMap.fromAscList 
            [ ((0, 1), Shift 6), ((0, 2), Shift 8), ((0, 3), Shift 7)
            , ((1, 0), Accept)
            , ((2, 0), Reduce (1, [NS 2])), ((2, 4), Reduce (1, [NS 2])), ((2, 6), Reduce (1, [NS 2]))
            , ((3, 0), Reduce (2, [NS 3])), ((3, 4), Reduce (2, [NS 3])), ((3, 6), Shift 12)
            , ((4, 0), Reduce (3, [NS 4])), ((4, 1), Shift 14), ((4, 2), Shift 15), ((4, 3), Shift 7), ((4, 4), Reduce (3, [NS 4])), ((4, 6), Reduce (3, [NS 4]))
            , ((5, 0), Reduce (4, [NS 5])), ((5, 1), Reduce (4, [NS 5])), ((5, 2), Reduce (4, [NS 5])), ((5, 3), Reduce (4, [NS 5])), ((5, 4), Reduce (4, [NS 5])), ((5, 6), Reduce (4, [NS 5]))
            , ((6, 0), Reduce (5, [TS 1])), ((6, 1), Reduce (5, [TS 1])), ((6, 2), Reduce (5, [TS 1])), ((6, 3), Reduce (5, [TS 1])), ((6, 4), Reduce (5, [TS 1])), ((6, 5), Shift 10), ((6, 6), Reduce (5, [TS 1]))
            , ((7, 1), Shift 6), ((7, 2), Shift 8), ((7, 3), Shift 7)
            , ((8, 0), Reduce (5, [TS 2])), ((8, 1), Reduce (5, [TS 2])), ((8, 2), Reduce (5, [TS 2])), ((8, 3), Reduce (5, [TS 2])), ((8, 4), Reduce (5, [TS 2])), ((8, 5), Shift 11), ((8, 6), Reduce (5, [TS 2]))
            , ((9, 4), Shift 23)
            , ((10, 1), Shift 6), ((10, 2), Shift 8), ((10, 3), Shift 7)
            , ((11, 1), Shift 6), ((11, 2), Shift 8), ((11, 3), Shift 7)
            , ((12, 1), Shift 19), ((12, 2), Shift 20), ((12, 3), Shift 7)
            , ((13, 0), Reduce (4, [NS 4, NS 5])), ((13, 1), Reduce (4, [NS 4, NS 5])), ((13, 2), Reduce (4, [NS 4, NS 5])), ((13, 3), Reduce (4, [NS 4, NS 5])), ((13, 4), Reduce (4, [NS 4, NS 5])), ((13, 6), Reduce (4, [NS 4, NS 5]))
            , ((14, 0), Reduce (5, [TS 1])), ((14, 1), Reduce (5, [TS 1])), ((14, 2), Reduce (5, [TS 1])), ((14, 3), Reduce (5, [TS 1])), ((14, 4), Reduce (5, [TS 1])), ((14, 5), Shift 21), ((14, 6), Reduce (5, [TS 1]))
            , ((15, 0), Reduce (5, [TS 2])), ((15, 1), Reduce (5, [TS 2])), ((15, 2), Reduce (5, [TS 2])), ((15, 3), Reduce (5, [TS 2])), ((15, 4), Reduce (5, [TS 2])), ((15, 5), Shift 22), ((15, 6), Reduce (5, [TS 2]))
            , ((16, 0), Reduce (1, [TS 1, TS 5, NS 1])), ((16, 4), Reduce (1, [TS 1, TS 5, NS 1])), ((16, 6), Reduce (1, [TS 1, TS 5, NS 1]))
            , ((17, 0), Reduce (1, [TS 2, TS 5, NS 1])), ((17, 4), Reduce (1, [TS 2, TS 5, NS 1])), ((17, 6), Reduce (1, [TS 2, TS 5, NS 1]))
            , ((18, 0), Reduce (2, [NS 3, TS 6, NS 3])), ((18, 4), Reduce (2, [NS 3, TS 6, NS 3])), ((18, 6), Reduce (2, [NS 3, TS 6, NS 3]))
            , ((19, 0), Reduce (5, [TS 1])), ((19, 1), Reduce (5, [TS 1])), ((19, 2), Reduce (5, [TS 1])), ((19, 3), Reduce (5, [TS 1])), ((19, 4), Reduce (5, [TS 1]))
            , ((20, 0), Reduce (5, [TS 2])), ((20, 1), Reduce (5, [TS 2])), ((20, 2), Reduce (5, [TS 2])), ((20, 3), Reduce (5, [TS 2])), ((20, 4), Reduce (5, [TS 2]))
            , ((21, 1), Shift 6), ((21, 2), Shift 8), ((21, 3), Shift 7)
            , ((22, 1), Shift 6), ((22, 2), Shift 8), ((22, 3), Shift 7)
            , ((23, 0), Reduce (5, [TS 3, NS 1, TS 4])), ((23, 1), Reduce (5, [TS 3, NS 1, TS 4])), ((23, 2), Reduce (5, [TS 3, NS 1, TS 4])), ((23, 3), Reduce (5, [TS 3, NS 1, TS 4])), ((23, 4), Reduce (5, [TS 3, NS 1, TS 4])), ((23, 6), Reduce (5, [TS 3, NS 1, TS 4]))
            , ((24, 0), Reduce (3, [NS 4, TS 1, TS 5, NS 1])), ((24, 4), Reduce (3, [NS 4, TS 1, TS 5, NS 1])), ((24, 6), Reduce (3, [NS 4, TS 1, TS 5, NS 1]))
            , ((25, 0), Reduce (3, [NS 4, TS 2, TS 5, NS 1])), ((25, 4), Reduce (3, [NS 4, TS 2, TS 5, NS 1])), ((25, 6), Reduce (3, [NS 4, TS 2, TS 5, NS 1]))
            ]
        , getReduceTable = YMap.fromAscList 
            [ ((0, 1), 1), ((0, 2), 2), ((0, 3), 3), ((0, 4), 4), ((0, 5), 5)
            , ((4, 5), 13)
            , ((7, 1), 9), ((7, 2), 2), ((7, 3), 3), ((7, 4), 4), ((7, 5), 5)
            , ((10, 1), 16), ((10, 2), 2), ((10, 3), 3), ((10, 4), 4), ((10, 5), 5)
            , ((11, 1), 17), ((11, 2), 2), ((11, 3), 3), ((11, 4), 4), ((11, 5), 5)
            , ((12, 3), 18), ((12, 4), 4), ((12, 5), 5)
            , ((21, 1), 24), ((21, 2), 2), ((21, 3), 3), ((21, 4), 4), ((21, 5), 5)
            , ((22, 1), 25), ((22, 2), 2), ((22, 3), 3), ((22, 4), 4), ((22, 5), 5)
            ]
        }

